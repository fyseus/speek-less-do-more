#### 1.命名风格

【强制】：

<u>命名不以下划线和$开始或结束</u>

<u>命名不允许使用中文方式，严禁拼音英文混合</u>

<u>严禁歧视性和侮辱性命名</u>

<u>**类名**采用UpperCamelCase风格，但以下情形例外：**DO / BO / DTO / VO / AO /  PO / UID** 等</u>

<u>**方法名、参数名、成员变量、局部变量**都统一使用 lowerCamelCase 风格</u>

- *“骆驼拼写法”（CamelCase）：依靠单词的大小写拼写的做法*

- *一个词的首字母小写，后面每个词的首字母大写，叫做“小骆驼拼写法”（lowerCamelCase）*

- *第一个词的首字母，以及后面每个词的首字母都大写，叫做“大骆驼拼写法”（UpperCamelCase）*

<u>**常量**命名全部**大写**，单词间用**下划线隔开**，**力求语义表达完整清楚，不要嫌名字长**</u>

<u>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾</u>

<u>类型与中括号紧挨相连来表示数组</u>

<u>POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列 化错误</u>

*说明：在本文 MySQL 规约中的建表约定第一条，表达是与否的变量采用 is_xxx 的命名方式，所以，需要 在设置从 is_xxx 到 xxx 的映射关系*

<u>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式</u>

<u>避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名， 使可理解性降低</u>

*说明：子类、父类成员变量名相同，即使是 public 类型的变量也能够通过编译，另外，局部变量在同一方 法内的不同代码块中同名也是合法的，这些情况都要避免。对于非 setter/getter 的参数名称也要避免与成 员变量名称相同。*

<u>杜绝完全不规范的缩写，避免望文不知义</u>

【推荐】：

<u>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组 合来表达</u>

<u>在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度</u>

<u>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式</u>

*将设计模式体现在名字中，有利于阅读者快速理解架构设计理念*

<u>接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，确定 与接口方法相关，并且是整个应用的基础常量。</u>

*说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。*

**接口和实现类的命名有两套规则：**

<u>1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</u>

<u>2）【推荐】如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。</u>

【参考】：

<u>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</u>

*说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。*

```
各层命名规约：
A) Service/DAO 层方法命名规约
1） 获取单个对象的方法用 get 做前缀。
2） 获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。
3） 获取统计值的方法用 count 做前缀。
4） 插入的方法用 save/insert 做前缀。
5） 删除的方法用 remove/delete 做前缀。
6） 修改的方法用 update 做前缀。
B) 领域模型命名规约
Java 开发手册
 4/59
1） 数据对象：xxxDO，xxx 即为数据表名。
2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。
3） 展示对象：xxxVO，xxx 一般为网页名称。
4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。
```

##### 常量定义

```
【强制】：
不允许魔法值（未预先定义的常量）直接出现在代码中
在long或Long赋值时，数值后使用大写字母L，而不是小写字母l，以免混淆
【推荐】：
不要使用一个常量类维护所有常量，要按功能分类维护
常量复用层次有五层：
跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下
应用内共享常量：放置在一方库中，通常是子模块中的constant目录下
子工程内部共享常量：即在当前子工程的constant目录下
包内共享常量：即在当前包下单独的constant目录下
类内共享常量：直接在类内部private static final定义
如果变量值仅在一个固定范围内变化用enum类型来定义
```

##### 代码格式

```
【强制】：
如果是大括号内为空，则{}，无需换行和空格；如果非空：左大括号前不换行，左大括号后换行，右大括号前换行，右大括号后还有else不换行，表示终止右大括号后换行
左小括号和右边相邻字符之间不出现空格；右小括号与左边相邻字符之间也不出现空格，左大括号前需要家空格
if/for/while/switch/do等保留字与括号之间都必须加空格
任何二目、三目运算符的左右两边都需要加一个空格
说明：包括=、&&、加减乘除等。
采用4个空格缩进，禁止使用Tab字符！！
说明：如果使用 Tab 缩进，必须设置 1 个 Tab 为 4 个空格。IDEA 设置 Tab 为 4 个空格时，请勿勾选 Use tab character；而在 Eclipse 中，必须勾选 insert spaces for tabs。
注释的双斜线与注释内容之间有且仅有一个空格
在进行强制类型转换时，右括号与强制转换值之间不需要任何空格隔开
单行字符限制不超过120个，超出要换行，换行遵守：
第二行相对第一行缩进4个空格，第三行开始，不再继续缩进
运算符与下文一起换行
方法调用的点符号与下文一起换行
方法调用中的多个参数需要换行时，在逗号后进行
在括号前不要换行
方法参数在定义和传入时，多个参数逗号后面必须加空格
IDE的text file encoding设置为 UTF-8；IDE中文件的换行符使用Unix格式，不要使用Windows格式
【推荐】：
单个方法总行数不超过80行
没有必要添加若干空格来使变量赋值等号与上一行对应位置的等号对齐
不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开以提高可读性
说明：任何情形，没有必要插入多个空行进行隔开。
```

##### OOP规约

```
【强制】：
避免用一个类对象引用访问此类的静态变量或静态方法（增加编译器解析成本），直接用类名来访问即可
所有的覆写方法，必须加@Override注解
说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。
相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object
说明：可变参数必须放置在参数列表的最后。（建议开发者尽量不用可变参数编程）
外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方法产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么
不能使用过时的类或方法
Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals
说明：推荐使用 JDK7 引入的工具类 java.util.Objects#equals(Object a, Object b)
所有整型包装类对象之间值的比较，全部使用equals方法比较
任何货币金额，均以最小货币单位且整型类型来进行存储
浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断
说明：指定一个误差范围
bigDecimal的等值比较应使用compareTo()方法，而不是equals()方法，euqals()方法比较值和精度，compareTo()方法忽略精度
定义数据对象DO类时，属性类型与数据库字段类型相匹配
禁止使用构造方法BigDecimal(double)的方式把double值转化为BigDecimal对象，存在精度损失风险
关于基本数据类型与包装数据类型的使用标准如下：
所有的POJO类属性必须使用包装数据类型
RPC方法的返回值和参数必须使用包装数据类型
所有的局部变量使用基本数据类型
说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或
者入库检查，都由使用者来保证。
定义DO/DTO/VO等POJO类时，不要设置任何属性默认值
序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，修改serialVersionUID值
构造方法里面禁止加入任何业务逻辑，如果右初始化逻辑，请放在init方法中
POJO类必须写toString方法。使用IDE中的工具：source> generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。
禁止在POJO类中，同时存在对应属性xxx的isXxx()和getXxx()方法
【推荐】：
使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException风险
当一个类有多个构造方法，或者多个同名方法，这些方法必须按顺序放置在一起，便于阅读，优于下一条
类内方法定义的顺序依次是：公有方法或保护方法》私有方法》getter/setter方法
setter方法中，参数名称与类成员名称一致，this.成员名=参数名。在getter/setter方法中，不要增加业务逻辑，增加排查问题的难度
循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。
说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append
操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。
final可以声明类、成员变量、方法、以及本地变量：
不允许被继承的类
不允许被修改引用的域对象
不允许被覆写的方法
不允许运行过程中重新赋值的局部变量
避免上下文重复使用一个变量，使用final关键字可以强制重新定义一个变量，方便更好地进行重构
慎用Object的clone方法来拷贝对象(浅拷贝)
类成员与方法访问控制从严：
1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。
2） 工具类不允许有 public 或 default 构造方法。
3） 类非 static 成员变量并且与子类共享，必须是 protected。
4） 类非 static 成员变量并且仅在本类使用，必须是 private。
5） 类 static 成员变量如果仅在本类使用，必须是 private。
6） 若是 static 成员变量，考虑是否为 final。
7） 类成员方法只供类内部调用，必须是 private。
8） 类成员方法只对继承类公开，那么限制为 protected
```

##### 日期时间

```
【强制】：
日期格式化时，传入 pattern 中表示年份统一使用小写的 y。
说明：日期格式化时，yyyy 表示当天所在的年，而大写的 YYYY 代表是 week in which year（JDK7 之后
引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的 YYYY
就是下一年。
正例：表示日期和时间的格式如下所示：
new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"
在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。
说明：日期格式中的这两对字母表意如下：
1） 表示月份是大写的 M；
2） 表示分钟则是小写的 m；
3） 24 小时制的是大写的 H；
4） 12 小时制的则是小写的 h。
获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime()。
说明：如果想获取更加精确的纳秒级时间值，使用 System.nanoTime 的方式。在 JDK8 中，针对统计时间
等场景，推荐使用 Instant 类
不允许在程序任何地方中使用：1）java.sql.Date。 2）java.sql.Time。 3）java.sql.Timestamp。
说明：第 1 个不记录时间，getHours()抛出异常；第 2 个不记录日期，getYear()抛出异常；第 3 个在构造
方法 super((time/1000)*1000)，在 Timestamp 属性 fastTime 和 nanos 分别存储秒和纳秒信息。
不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误。
int daysOfThisYear = LocalDate.now().lengthOfYear()
【推荐】：
避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29日。
使用枚举值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份month 取值在 0-11 之间。
```

##### 集合处理

```
【强制】：
关于 hashCode 和 equals 的处理，遵循如下规则：
1） 只要覆写 equals，就必须覆写 hashCode。
2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两种方法。
3） 如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。
说明：String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。
判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。
说明：在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。
在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要使
用含有参数类型为 BinaryOperator，参数名为 mergeFunction 的方法，否则当出现相同 key值时会抛出 IllegalStateException 异常。
说明：参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。
ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。
说明：subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于 SubList 的所有操作最终会反映到原列表上。
使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，不可以对其进行添加元素操作，否则会抛出 UnsupportedOperationException 异常
Collections 类返回的对象，如emptyList()/singletonList()等都是 immutable list，不可对其进行添加或者删除元素的操作
在 subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。
使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。
```

P17
